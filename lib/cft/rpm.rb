require 'rpm'

module Cft::RPM
    # Generate the state of the RPM DB +root+ in file +fname+
    # The RPM database must be located in +/var/lib/rpm+ underneath
    # +root+
    # The output file +fname+ is overwritten; the format of the file
    # is internal to this module. Use +readstate+ if you need to read
    # the file
    def self.genstate(fname, root = nil)
        begin
            db = RPM::DB::open(false, root)
            File::open(fname, "w") do |f|
                db.each do |pkg|
                    f.print(pkg.sprintf("%{NAME}.%{ARCH} "))
                    f.puts(
                           "#{pkg.version.e || 0} #{pkg.version.v} #{pkg.version.r}")
                end
            end
        ensure
            # FIXME: Somehow we are not closing the rpmdb
            # right; it stil seems to think we have a lock
            db.close() unless db.nil?
            db = nil
        end
        return nil
    end

    # Read the state file +fname+ generated by +genstate+
    # Returns a hash, where each entry maps +name.arch+ to a
    # list of RPM::Version
    def self.readstate(fname)
        result = {}
        return result unless File::exist?(fname)
        File::open(fname, "r") do |f|
            f.each_line do |l|
                na, e, v, r = l.split
                result[na] ||= []
                result[na] << RPM::Version::new(v, r, e)
            end
        end
        return result
    end
    
    # Compute the diff between the two package sets +before+ and +after+, 
    # which must both be package lists as returned by +readstate+
    # Returns the diff as a hash with three keys: +:installed+, +:erased+, 
    # and +:updated+; each of these keys is associated with a dict associating
    # the +name.arch+ with a list of versions; for updated packages, the 
    # version(s) are the ones that are in +after+ but weren't in +before+
    def self.diff(before, after)
        erased, installed, updated  = {}, {}, {}
        (before.keys + after.keys).uniq.each do |na|
            if ! before.key?(na)
                installed[na] = after[na]
            elsif ! after.key?(na)
                erased[na] = before[na]
            else
                upd = setdiff(after[na], before[na])
                updated[na] = upd unless upd.empty?
            end
        end
        return { :erased => erased, :installed => installed,
            :updated => updated }
    end

    # Return the diff between the two package sets +before+ and +after+ as 
    # two +TransBuckets+. Each bucket contains package +TransObjects+
    def self.transdiff(before, after)
        tbef, taft = [ "package_before", "package_after"].collect do |n|
            bucket = Puppet::TransBucket.new
            bucket.keyword = :manifest
            bucket.type = n
            bucket
        end
        (before.keys + after.keys).uniq.each do |na|
            if ! before.key?(na)
                push_into_bucket(taft, na, after[na])
            elsif ! after.key?(na)
                push_into_bucket(tbef, na, before[na])
            else
                push_into_bucket(taft, na, setdiff(after[na], before[na]))
                push_into_bucket(tbef, na, setdiff(before[na], after[na]))
            end
        end
        return [tbef, taft]
    end

    # Return a list of the packages that own the file +fname+
    def self.byfile(db, fname)
        fname = fname.sub(%r@#{File::SEPARATOR}$@, "")
        iter = db.init_iterator(nil, nil)
        pkgs = iter.regexp(RPM::TAG_BASENAMES, RPM::MIRE_DEFAULT, 
                           File::basename(fname))
        return pkgs.select { |k| k.files.find { |f| f.path == fname } }
    end

    private
    def self.push_into_bucket(bucket, na, versions)
        versions.each do |v|
            tobj = Puppet::TransObject.new(na, :package)
            tobj[:ensure] = v.to_vre
            bucket << tobj
        end
    end

    # Same as +a - b+, but works even if the elements in +a+ and +b+
    # don't fulfill v1 == v2 iff v1.hash == v2.hash
    def self.setdiff(a, b)
        a.reject { |e| b.include?(e) }
    end
end
