require 'rpm'

module Cft::RPM
    # Generate the state of the RPM DB +root+ in file +fname+
    # The RPM database must be located in +/var/lib/rpm+ underneath
    # +root+
    # The output file +fname+ is overwritten; the format of the file
    # is internal to this module. Use +readstate+ if you need to read
    # the file
    def self.genstate(fname, root = nil)
        begin
            db = RPM::DB::open(false, root)
            File::open(fname, "w") do |f|
                db.each do |pkg|
                    f.print(pkg.sprintf("%{NAME}.%{ARCH} "))
                    f.puts(
                           "#{pkg.version.e || 0} #{pkg.version.v} #{pkg.version.r}")
                end
            end
        ensure
            db.close() unless db.nil?
        end
        return nil
    end

    # Read the state file +fname+ generated by +genstate+
    # Returns a hash, where each entry maps +name.arch+ to a
    # list of RPM::Version
    def self.readstate(fname)
        result = {}
        File::open(fname, "r") do |f|
            f.each_line do |l|
                na, e, v, r = l.split
                result[na] ||= []
                result[na] << RPM::Version::new(v, r, e)
            end
        end
        return result
    end
    
    # Compute the diff between the two package sets +before+ and +after+, 
    # which must both be package lists as returned by +readstate+
    # Returns the diff as a hash with three keys: +:installed+, +:erased+, 
    # and +:updated+; each of these keys is associated with a dict associating
    # the +name.arch+ with a list of versions; for updated packages, the 
    # version(s) are the ones that are in +after+ but weren't in +before+
    def self.diff(before, after)
        erased, installed, updated  = {}, {}, {}
        (before.keys + after.keys).uniq.each do |na|
            if ! before.key?(na)
                installed[na] = after[na]
            elsif ! after.key?(na)
                erased[na] = before[na]
            else
                # FIXME: We can't just say after[na] - before[na]
                # since that uses a hash internally, and RPM::Version
                # does not fulfill v1 == v2 iff v1.hash == v2.hash
                # (though ruby does not require that, strictly speaking)
                upd = after[na].reject{ |v| before[na].include?(v) }
                updated[na] = upd unless upd.empty?
            end
        end
        return { :erased => erased, :installed => installed,
            :updated => updated }
    end
end
