require 'rpm'
require 'yaml'
require 'pathname'

module Cft::RPM
    # Generate the state of the RPM DB +root+ in file +fname+
    # The RPM database must be located in +/var/lib/rpm+ underneath
    # +root+
    # The output file +fname+ is overwritten; the format of the file
    # is internal to this module. Use +readstate+ if you need to read
    # the file
    def self.genstate(fname, root = nil)
        withdb(root) do |db|
            File::open(fname, "w") do |f|
                db.each do |pkg|
                    f.print(pkg.sprintf("%{NAME}.%{ARCH} "))
                    f.puts(
                           "#{pkg.version.e || 0} #{pkg.version.v} #{pkg.version.r}")
                end
            end
        end
    end

    # Read the state file +fname+ generated by +genstate+
    # Returns a hash, where each entry maps +name.arch+ to a
    # list of RPM::Version
    def self.readstate(fname)
        result = {}
        return result unless File::exist?(fname)
        File::open(fname, "r") do |f|
            f.each_line do |l|
                na, e, v, r = l.split
                result[na] ||= []
                result[na] << RPM::Version::new(v, r, e)
            end
        end
        return result
    end
    
    # Compute the diff between the two package sets +before+ and +after+, 
    # which must both be package lists as returned by +readstate+
    # Returns the diff as a hash with three keys: +:installed+, +:erased+, 
    # and +:updated+; each of these keys is associated with a dict associating
    # the +name.arch+ with a list of versions; for updated packages, the 
    # version(s) are the ones that are in +after+ but weren't in +before+
    def self.diff(before, after)
        erased, installed, updated  = {}, {}, {}
        (before.keys + after.keys).uniq.each do |na|
            if ! before.key?(na)
                installed[na] = after[na]
            elsif ! after.key?(na)
                erased[na] = before[na]
            else
                upd = setdiff(after[na], before[na])
                updated[na] = upd unless upd.empty?
            end
        end
        return { :erased => erased, :installed => installed,
            :updated => updated }
    end

    # Return the diff between the two package sets +before+ and +after+ as 
    # two +TransBuckets+. Each bucket contains package +TransObjects+
    def self.transdiff(before, after)
        tbef, taft = [ "package_before", "package_after"].collect do |n|
            bucket = Puppet::TransBucket.new
            bucket.keyword = :manifest
            bucket.type = n
            bucket
        end
        (before.keys + after.keys).uniq.each do |na|
            if ! before.key?(na)
                push_into_bucket(taft, na, after[na])
            elsif ! after.key?(na)
                push_into_bucket(tbef, na, before[na])
            else
                push_into_bucket(taft, na, setdiff(after[na], before[na]))
                push_into_bucket(tbef, na, setdiff(before[na], after[na]))
            end
        end
        return [tbef, taft]
    end

    # Return a list of the packages that own the file +fname+
    # The returned list consists of +PackageFile+ objects
    def self.byfile(db, path)
        path = Pathname.new(path).cleanpath
        return [] unless path.exist?
        realpath = path.realpath.to_str
        iter = db.init_iterator(nil, nil)
        pkgs = iter.regexp(RPM::TAG_BASENAMES, RPM::MIRE_DEFAULT, 
                           File::basename(realpath))
        return pkgs.inject([]) do |result, k|
            if file = k.files.find { |f| f.path == realpath }
                result << PackageFile.new(path.to_str, k, file)
            end
            result
        end
    end

    # Compute which packages on +packages+ shadow other packages on the
    # list by requiring them. The +packages+ must be a list of
    # +RPM::Package+ objects. The result is a dict where the keys are
    # +RPM::Package+ objects and the values are lists of +RPM::Package+
    # objects. The list contains all the packages in +packages+ that are
    # directly required by the key
    def self.shadow(packages)
        result = {}
        packages.each do |leaf|
            result[leaf] ||= []
            leaf.requires.each do |req|
                packages.reject{ |k| k == leaf }.each do |k|
                    if req.name[0,1] == '/'
                        if k.files.find { |file| file.path == req.name }
                            result[leaf] << k
                        end
                    else
                        result[leaf] << k if req.satisfy?(k)
                    end
                end
            end
        end
        result.each_value { |v| v.uniq! }
        return result
    end

    # Compute dependency information for packages that have been
    # changed between +before_file+ and +after_file+
    # and store that in +shadow_file+
    def self.genshadow(shadow_file, before_file, after_file, root=nil)
        before = readstate(before_file)
        after = readstate(after_file)
        diff = diff(before, after)
        lst = diff[:installed].merge(diff[:updated]) { |k, o, n| (o + n).uniq }
        pkgs = []
        withdb(root) do |db|
            lst.each do |na, versions|
                comps = na.split(".")
                arch = comps.pop
                name = comps.join(".")
                iter = db.init_iterator(RPM::TAG_NAME, name) || []
                pkgs += iter.select do |pkg|
                    arch == pkg.arch && versions.include?(pkg.version)
                end
            end
        end
        sh = {}
        shadow(pkgs).each do |k,v|
            sh[PackageHandle.new(k)] = v.collect { |p| PackageHandle.new(p) }
        end
        File::open(shadow_file, "w") do |out|
            # We have to dump as arrays, otherwise YAML chokes
            YAML.dump(sh.to_a, out)
        end
        return sh
    end

    # Return the shadow stored by +genshadow+ in +shadow_file+
    # as a hash mapping +PackageHandle+ objects to lists of 
    # +PackageHandle+ objects. The meaning of the hash is the same as the
    # one returned by +shadow+
    def self.readshadow(fname)
        return {} unless File::exist?(fname)
        File::open(fname, "r") do |f| 
            YAML::load(f).inject({}) { |m, e| m[e[0]] = e[1] ; m }
        end
    end

    # The 'id' of a package, just its name, version and arch
    class PackageHandle
        include Comparable

        attr_reader :name, :arch, :version
        def initialize(package)
            @name = package.name
            @version = package.version
            @arch = package.arch
        end

        def <=>(other)
            r = (name <=> other.name)
            return r unless r == 0
            r = version <=> other.version
            return r unless r == 0
            return arch <=> other.arch
        end
        
        def eql?(other)
            self == other
        end

        def hash
            return 37 * (name.hash + 37 * version.hash) + arch.hash
        end

        def to_s
            "#{name}-#{version}.#{arch}"
        end
    end

    # A file in a package; this class is mainly uised for serialization
    # and identifies the package by its name, arch and version
    class PackageFile
        attr_reader :path, :file, :package

        def initialize(path, package, file)
            @path = path
            @file = file
            @package = PackageHandle.new(package)
        end

        def name 
            @package.name
        end
        
        def arch 
            @package.arch
        end
        
        def version 
            @package.version
        end

        # Write a list of +PackageFile+ objects to the file +fname+
        # The list will have entries for each file in +files+ that is
        # owned by a package
        def self.genlist(fname, files)
            Cft::RPM::withdb(nil) do |db|
                lst = files.inject([]) do |lst, f|
                    lst.concat(Cft::RPM::byfile(db, f))
                end
                File::open(fname, "w") do |out|
                    YAML.dump(lst, out)
                end
            end
        end

        def self.readlist(fname)
            return [] unless File::exist?(fname)
            File::open(fname, "r") { |f| YAML::load(f) }
        end
    end

    def self.withdb(root = nil, &block)
        begin
            db = RPM::DB::open(false, root)
            result = yield(db)
        ensure
            db.close() unless db.nil?
            GC.start
        end
        return result
    end

    private
    def self.push_into_bucket(bucket, na, versions)
        versions.each do |v|
            tobj = Puppet::TransObject.new(na, :package)
            tobj[:ensure] = v.to_vre
            bucket << tobj
        end
    end

    # Same as +a - b+, but works even if the elements in +a+ and +b+
    # don't fulfill v1 == v2 iff v1.hash == v2.hash
    def self.setdiff(a, b)
        a.reject { |e| b.include?(e) }
    end

end

# This really needs to go into ruby-rpm
module RPM
    module YAML
        def to_yaml( opts = {} )
            ::YAML::quick_emit( object_id, opts ) do |out|
                out.map( taguri, to_yaml_style ) do |map|
                    self.class.yaml_attributes.each do |m|
                        map.add( m, send(m) )
                    end
                end
            end
        end
    end
    
    class File
        include YAML
        yaml_as "tag:ruby.rpm.org,2007:file"
        def self.yaml_attributes
            %w{path md5sum link_to size mtime owner group
           rdev mode attr state}
        end
        def self.yaml_new( klass, tag, val )
            # FIXME: ruby-rpm file_initialize (file.c:26) segfaults
            # on line 39 when link_to is nil
            val["link_to"] = "" unless val["link_to"]
            args = yaml_attributes.collect { |a| val[a] }
            self.new(*args)
        end
    end

    class Version
        include YAML
        yaml_as "tag:ruby.rpm.org,2007:version"
        def self.yaml_attributes
            %w{v r e}
        end
        def self.yaml_new( klass, tag, val )
            args = yaml_attributes.collect { |a| val[a] }
            self.new(*args)
        end
    end
end
